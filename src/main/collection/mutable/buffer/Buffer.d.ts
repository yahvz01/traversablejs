import Traversable from "../../Traversable";
import Optional from "../../../util/Optional";
import Gen from "../../generic/Gen";
import MutableSeq from "../MutableSeq";
declare class Buffer<_Tp> implements MutableSeq<_Tp> {
    private buffer;
    static from<_Tp>(data: Array<_Tp>): Buffer<_Tp>;
    static of<_Tp>(...data: _Tp[]): Buffer<_Tp>;
    private constructor();
    readonly size: number;
    readonly head: _Tp;
    readonly headOptional: Optional<_Tp>;
    readonly init: Traversable<_Tp>;
    readonly isEmpty: boolean;
    readonly last: _Tp;
    readonly lastOptional: Optional<_Tp>;
    readonly tail: Traversable<_Tp>;
    apply(index: number): Optional<_Tp>;
    indices(): Gen;
    pop(): _Tp;
    push(e: _Tp): void;
    remove(index: number): void;
    shift(): _Tp;
    unshift(e: _Tp): void;
    updated(index: number, e: _Tp): void;
    count(predicate: (e: _Tp) => boolean): number;
    exists(predicate: (e: _Tp) => boolean): boolean;
    filter(predicate: (e: _Tp) => boolean): Traversable<_Tp>;
    foldLeft(init: _Tp, folding: (acc: _Tp, curr: _Tp) => _Tp): _Tp;
    foldRight(init: _Tp, folding: (acc: _Tp, curr: _Tp) => _Tp): _Tp;
    forall(predicate: (e: _Tp) => boolean): boolean;
    foreach(consumer: (e: _Tp) => void): void;
    hasDefiniteSize(): boolean;
    map<K>(f: (e: _Tp) => K): Traversable<K>;
    slice(from: number, until: number): Traversable<_Tp>;
    take(index: number): Traversable<_Tp>;
    takeWhile(predicate: (e: _Tp) => boolean): Traversable<_Tp>;
    drop(index: number): Traversable<_Tp>;
    dropWhile(predicate: (e: _Tp) => boolean): Traversable<_Tp>;
}
export default Buffer;
//# sourceMappingURL=Buffer.d.ts.map