import IndexedSeq from "../IndexedSeq";
import Traversable from "../../../Traversable";
import Optional from "../../../../util/Optional";
import Seq from "../../Seq";
import Gen from "../../../generic/Gen";
declare class Vector<_Tp> implements IndexedSeq<_Tp> {
    private dataSet;
    private _size;
    static of<_Tp>(...data: _Tp[]): Vector<_Tp>;
    constructor(...data: _Tp[]);
    readonly size: number;
    readonly isEmpty: boolean;
    readonly head: _Tp;
    readonly headOptional: Optional<_Tp>;
    readonly init: Traversable<_Tp>;
    readonly last: _Tp;
    readonly lastOptional: Optional<_Tp>;
    readonly tail: Traversable<_Tp>;
    apply(index: number): Optional<_Tp>;
    count(p: (e: _Tp) => boolean): number;
    take(index: number): Traversable<_Tp>;
    takeWhile(predicate: (e: _Tp) => boolean): Traversable<_Tp>;
    drop(index: number): Traversable<_Tp>;
    dropWhile(predicate: (e: _Tp) => boolean): Traversable<_Tp>;
    filter(predicate: (e: _Tp) => boolean): Traversable<_Tp>;
    forall(predicate: (e: _Tp) => boolean): boolean;
    exists(predicate: (e: _Tp) => boolean): boolean;
    foldLeft(init: _Tp, folding: (acc: _Tp, curr: _Tp) => _Tp): _Tp;
    foldRight(init: _Tp, folding: (acc: _Tp, curr: _Tp) => _Tp): _Tp;
    foreach(consumer: (e: _Tp) => void): void;
    hasDefiniteSize(): boolean;
    indices(): Gen;
    map<K>(f: (e: _Tp) => K): Traversable<K>;
    remove(index: number): Seq<_Tp>;
    slice(from: number, until: number): Traversable<_Tp>;
    unshift(e: _Tp): Seq<_Tp>;
    shift(): Seq<_Tp>;
    push(e: _Tp): Seq<_Tp>;
    pop(): Seq<_Tp>;
    updated(index: number, e: _Tp): Seq<_Tp>;
    private copyEmptyDataSet;
    private copyDataSet;
}
export default Vector;
//# sourceMappingURL=Vector.d.ts.map